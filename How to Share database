ğŸ”· What Problem Are We Solving?

You want:

Multiple people to work on database changes

No one should directly damage the main database

Changes should be trackable

You (or one person) should have final control

ğŸ‘‰ This is called Database Change Management using Git

ğŸ”· Core Idea (Very Important)

âŒ We do NOT share the live database
âœ… We share SQL files using Git
âœ… One person controls the main DB (DBA role)

Database â‰  Code
SQL scripts = Code

ğŸ”· Roles (From Scratch)
ğŸ‘‘ 1. DBA (Database Administrator)

Usually:

Team lead

Project owner

OR you

DBA controls:

Main database

Who can access it

Which changes go live

ğŸ‘¨â€ğŸ’» 2. Developers (Team Members)

Do not touch main DB

Work on local database

Create SQL scripts

Push scripts to Git

ğŸ”· Architecture (Simple View)
Developer 1  â”€â”
Developer 2  â”€â”¼â”€â”€> Git Repository (SQL files)
Developer 3  â”€â”˜              â”‚
                              â†“
                        DBA reviews
                              â†“
                        Main Database

ğŸ”· Step 1: Decide Your Database

Example:

MySQL

Oracle

PostgreSQL

ğŸ‘‰ For explanation, Iâ€™ll keep it generic (works for all)

ğŸ”· Step 2: Create the MAIN Database (DBA only)

This is the central database.

Example:

CREATE DATABASE project_db;


This DB exists:

On your system

OR on a server

Only DBA has full control

ğŸ”· Step 3: Create DBA User

This user has FULL POWER.

-- MySQL
CREATE USER 'db_admin' IDENTIFIED BY 'password';
GRANT ALL PRIVILEGES ON project_db.* TO 'db_admin';


ğŸ‘‰ Only this user:

Creates tables

Alters schema

Deletes data

ğŸ”· Step 4: Developers Create LOCAL Databases

Each developer does this on their own laptop.

CREATE DATABASE project_db_local;


They can:

Create tables

Modify schema

Test queries freely

âš ï¸ These changes are NOT live

ğŸ”· Step 5: Create Git Repository (Very Important)

Create a Git repo called:

project-database

ğŸ”· Step 6: Proper Folder Structure (Industry Style)
project-database/
â”‚
â”œâ”€â”€ 01_schema/
â”‚   â”œâ”€â”€ create_tables.sql
â”‚
â”œâ”€â”€ 02_alter/
â”‚   â”œâ”€â”€ add_email_to_user.sql
â”‚
â”œâ”€â”€ 03_data/
â”‚   â”œâ”€â”€ insert_initial_data.sql
â”‚
â”œâ”€â”€ 04_indexes/
â”‚   â”œâ”€â”€ user_email_index.sql
â”‚
â””â”€â”€ README.md


ğŸ“Œ Each file = ONE logical change

ğŸ”· Step 7: How a Developer Works (Real Flow)
Example: Developer wants to add a column

1ï¸âƒ£ Developer modifies local DB

ALTER TABLE users ADD email VARCHAR(100);


2ï¸âƒ£ Create SQL file:

02_alter/add_email_to_user.sql


3ï¸âƒ£ Put SQL inside:

ALTER TABLE users ADD email VARCHAR(100);


4ï¸âƒ£ Commit to Git:

git add .
git commit -m "Added email column to users table"
git push

ğŸ”· Step 8: DBA Review Process

DBA:

Pulls latest code

Reads SQL carefully

Checks:

No DROP without reason

No data loss

Naming standards

git pull

ğŸ”· Step 9: Backup Before Applying (CRITICAL)
-- Example
CREATE TABLE users_backup AS SELECT * FROM users;


ğŸ“Œ Always backup before running scripts

ğŸ”· Step 10: Apply Script on MAIN Database

DBA runs:

ALTER TABLE users ADD email VARCHAR(100);


âœ”ï¸ Change goes live
âœ”ï¸ Everyoneâ€™s app now sees it

ğŸ”· Step 11: Record Execution (Best Practice)

DBA updates a file:

executed_changes.md


Example:

âœ” 2026-01-09 add_email_to_user.sql executed

ğŸ”· Database Permissions (Optional but Professional)
Developer DB User (Read / Write only)
GRANT SELECT, INSERT, UPDATE ON project_db.* TO 'dev_user';

No DROP, No ALTER
ğŸ”· Why This System Is Powerful
Feature	Benefit
Git History	Know who changed what
SQL Files	Easy rollback
DBA Control	Safe DB
Local Testing	No live damage
Industry Standard	Interview ready
ğŸ”· Common Mistakes (Avoid These âŒ)

Sharing live DB credentials

Running scripts without backup

Multiple changes in one SQL file

No naming convention

No review process

ğŸ”· Real Company Rule (Remember This)

Developers propose changes
DBA approves & executes
